(defun silla (array)
    (loop
        for a from 0
        do
        (setf resp T)
        (setf var (aref array a 0));;defino mayor del j al primero
        (dotimes (b j) 
            (setf xy (aref array a b))
            (when (> xy var)
                (setf maxj b)
                (setf var xy)
            )
        );;conseguir el mayor de la fila i
        (dotimes (m i)
            (setf obj (aref array m maxj))
            (if (< obj var)
                (setf resp nil)
            )
        )
        (when (eq resp T)
            (format t "~%Silla: ~a" var)
            (format t "~%(i, j): ~a" (list a maxj))
            (return-from silla nil)
        )
    )
)


(defun validar(e)
    (setf var nil)
    (dotimes (a i)
        (dotimes (b j)
            (setf k (aref array a b))
            (when (not (eq k nil))
                (when (eq e k) 
                    (setf var T)
                )
            )
        )
    )
    (if (eq var T)
        (format t "~%Ingrese un valor diferente a los anteriores.~%")
    )
    (return-from validar var)
)

(format t "~%Ingrese las dimension de su matriz: (i, j)")
(format t "~%i : ")
(defvar i (read))
(format t "j : ")
(defvar j (read))
(setf dim (list i j))
(setf array (make-array dim))
(format t "~%Elementos de la matriz: ~%")
(dotimes (a i)
    (dotimes (b j)
        (loop
            do
            (format t "(~a, " a)
            (format t "~a): " b)
            (setf e (read))
            while (validar e)
        )
            (setf dim (list a b))
            (setf (apply #'aref array dim) e)
    )
)
(format t "~%Matriz: ~a" array)


(silla array)
